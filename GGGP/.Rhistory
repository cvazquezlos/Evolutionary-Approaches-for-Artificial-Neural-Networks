print(s_p2_parts)
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
parts <- c(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}),
lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}))
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
print(s_p1_parts)
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
print(s_p2_parts)
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
lapply(s_p1_parts, print)
parts <- c(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}),
lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}))
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
print(s_p1_parts)
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
print(s_p2_parts)
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
lapply(s_p1_parts, print)
print(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}))
parts <- c(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}),
lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}))
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
print(s_p1_parts)
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
print(s_p2_parts)
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
lapply(s_p1_parts, print)
print(sapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}))
parts <- c(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}),
lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}))
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
print(s_p1_parts)
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
print(s_p2_parts)
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
lapply(s_p1_parts, print)
print(sapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}))
parts <- c(sapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}),
sapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}))
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
View(children)
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
parts <- c(unlist(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}), use.names = F),
unlist(lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}), use.names = F))
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
View(children)
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
parts <- c(unlist(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}), use.names = F),
unlist(lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}), use.names = F))
print(paarts)
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
parts <- c(unlist(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}), use.names = F),
unlist(lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}), use.names = F))
print(parts)
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
parts <- c(lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}}),
lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}}))
print(parts)
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
for (k in c(1:2)) {
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(parts[[k]])), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
}
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
s_p1_parts <- lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}})
s_p2_parts <- lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}})
print(s_p1_parts)
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(s_p1_parts)), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(s_p2_parts)), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
print("--------------------------------------")
return(df)
}
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
s_p1_parts <- lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}})
s_p2_parts <- lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}})
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(s_p1_parts)), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(s_p2_parts)), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
return(df)
}
#save.image("01022019 - Population creation.RData")
#load("01022019 - Population creation.RData")
# First generation
#save.image("02022019 - Changes over operators.RData")
load("02022019 - Changes over operators.RData")
#save.image("01022019 - Population creation.RData")
#load("01022019 - Population creation.RData")
# First generation
#save.image("02022019 - Changes over operators.RData")
load("02022019 - Changes over operators.RData")
######################################################## EVOLUTIONARY OPERATORS ########################################################
generation <- function(n) {
population <- GrammarRandomExpression(CreateGrammar(GRAMMAR), n)
i <- 1
for (individual in population) {
population[[i]] <- list(id = id, architecture = gsub("\"", "", toString(individual)), evaluated = FALSE, loss = NA, metric = NA,
saved_model = NA)
i <- i + 1
id <<- id + 1
}
return(as.data.frame(do.call(rbind, population)))
}
evaluation <- function(individual, split_crit, mode) {
# Neurons extraction
hidden_layers <- numeric(0)
i <- 0
if (split_crit == 0) {
splitting <- head(strsplit(individual$architecture[[1]], "/")[[1]], -1)
} else {
print(individual$architecture)
splitting <- head(strsplit(toString(individual$architecture), "/")[[1]], -1)
}
for (layer in splitting) {
if (i != 0) {
hidden_layers[i] <- nchar(layer)
}
i <- i + 1
}
# Individual evaluation
model <- keras_model_sequential()
model %>% layer_dense(units = hidden_layers[1], input_shape = c(I), activation = "relu")
for (layer in tail(hidden_layers, 1)) {
model %>% layer_dense(units = layer, activation = "relu")
}
if (mode == 0) {
model %>% layer_dense(units = O, activation = "softmax")
model %>% compile(
optimizer = "adam",
loss = "categorical_crossentropy",
metrics = c("accuracy")
)
} else {
# TODO: Regression NN output layer.
}
history <- model %>% fit(rbind(X_train, X_validation), rbind(y_train, y_validation), validation_split = 0.235294, epochs = 1000,
verbose = 0, callbacks = list(
callback_early_stopping(monitor = "val_loss", min_delta = 0, patience = 100, verbose = 1, mode = "auto")
))
plot(history)
model_name <- paste0(str_replace_all(individual$architecture, "/", "_"), "-", individual$id)
ggsave(paste0("data/history/", model_name, ".pdf"))
save_model_hdf5(model, paste0("data/model/", model_name, ".h5"))
score <- model %>% evaluate(X_validation, y_validation)
individual$evaluated <- TRUE
individual$loss <- score['loss'][[1]]
individual$metric <- score['acc'][[1]]
individual$saved_model <- model_name
return(individual)
}
# Tournament selection
selection <- function(no_childs) {
no_parents <- no_childs
matting_pool <- data.frame()
for (n in c(1:(no_childs/2))) {
parents_sample <- population[sample(nrow(population), no_childs/2),]
ordered_parents_sample <- parents_sample[order(unlist(parents_sample$loss)),]
matting_pool <- rbind(matting_pool, head(ordered_parents_sample, 2))
}
return(matting_pool)
}
crossover <- function(parents) {
s_p1_parts <- extract_hidden_layers(parents$architecture[[1]])
s_p2_parts <- extract_hidden_layers(parents$architecture[[2]])
random_s_p1 <- sample(s_p1_parts, 1)
random_s_p2 <- sample(s_p2_parts, 1)
s_p1_parts <- lapply(s_p1_parts, function(x) {if(x==random_s_p1) {random_s_p2} else {x}})
s_p2_parts <- lapply(s_p2_parts, function(x) {if(x==random_s_p2) {random_s_p1} else {x}})
df <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = double(),
metric = double(),
saved_model = character(),
stringsAsFactors = FALSE)
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(s_p1_parts)), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
df <- rbind(df, data.frame(id = id, architecture = toString(add_inout_layers(s_p2_parts)), evaluated = FALSE, loss = NA, metric = NA, saved_model = NA))
id <<- id + 1
return(df)
}
######################################################### AUXILIARY FUNCTIONS #########################################################
add_inout_layers <- function(hidden) {
return(paste(strrep("n", I), "/", paste0(hidden, collapse = "/"), "/", strrep("n", O), sep = ""))
}
extract_hidden_layers <- function(architecture) {
split <- strsplit(architecture, split = "/")
return(tail(head(split[[1]], -1), -1))
}
#######################################################################################################################################
########################################################### MAIN ALGORITHM ############################################################
#######################################################################################################################################
#save.image("01022019 - Population creation.RData")
#load("01022019 - Population creation.RData")
# First generation
save.image("02022019 - Changes over operators.RData")
# Selection process
matting_pool <- selection(10)
# Crossover process
children <- data.frame(id = integer(),
architecture = character(),
evaluated = logical(),
loss = numeric(),
metric = numeric(),
saved_model = character(),
stringsAsFactors = FALSE)
for (i in c(1:(nrow(matting_pool)/2))) {
j <- (i*2)-1
children <- rbind(children, crossover(matting_pool[c(j:(j+1)),]))
}
# Children training process
for (individual in 1:nrow(children)) {
children[individual,] = evaluation(children[individual,], 1, 0)
}
View(children)
replacement <- function(population, children) {
max_population <- rbind(population, children)
ordered_max_population <- max_population[order(unlist(max_population$loss)),]
return(ordered_max_population[c(1:50),])
}
# Elitist selection
population <- replacement(population, children)
View(population)
View(population)
